<!DOCTYPE html>
<html>

<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <title>flv.js demo</title>
    <link rel="stylesheet" type="text/css" href="demo.css" />
    <script src="jquery-3.4.1.min.js"></script>
    <script type="text/javascript" src="vec2.min.js"></script>
</head>

<body>
    
    <div class="mainContainer" style="width:100%">
        <div>
            <div id="streamURL">
                <div class="url-input">
                    <label for="sURL">Stream URL:</label>
                    <input id="sURL" type="text" value="http://172.30.13.52:8080/wick2.flv" />
                    <button onclick="switch_mds()">Switch to MediaDataSource</button>
                </div>
                <div class="options" style="visibility: hidden">
                    <input type="checkbox" id="isLive" onchange="saveSettings()" />
                    <label for="isLive">isLive</label>
                    <input type="checkbox" id="withCredentials" onchange="saveSettings()" />
                    <label for="withCredentials">withCredentials</label>
                    <input type="checkbox" id="hasAudio" onchange="saveSettings()" checked />
                    <label for="hasAudio">hasAudio</label>
                    <input type="checkbox" id="hasVideo" onchange="saveSettings()" checked />
                    <label for="hasVideo">hasVideo</label>
                </div>
            </div>
            <div id="mediaSourceURL" class="hidden">
                <div class="url-input">
                    <label for="msURL">MediaDataSource JsonURL:</label>
                    <input id="msURL" type="text" value="http://172.30.13.52:8080/wick2.flv" />
                    <button onclick="switch_url()">Switch to URL</button>
                </div>
            </div>
        </div>
        <div><div style="display: flex; width:100%; height:500px">
            <textarea disabled rows="15" cols="80" id="pane_output" style="border:solid 1px orange; width:20%"></textarea>
            <table style="font-size:12px; width:30%;">
                <col style="width:20%">
                <col style="width:80%">
                <tr>
                    <td>Pane:</td><td> <select id="pane_dropdown"></select></td>
                </tr>
                <tr>
                    <td><button onclick="add_pane()">Add Pane</button></td>
                </tr>
                <tr>
                    <td>Show Debug:</td><td><input type="checkbox" name="show_original" checked></td>
                </tr>
                <tr>
                    <td>Scene Type:</td><td><select name="scene_type"> <option value="ceiling">ceiling</option> <option value="floor">floor</option> <option value="wall">wall</option></select></td>
                </tr>

                <tr>
                    <td>azimuth</td><td><input type="range" min="0" max="360" value="0" class="slider" name="azimuth" style="width:800px"><output name="azimuth_output">0</output></td>
                </tr>
                <tr>
                    <td>lens</td><td><input type="range" min="0" max="2000" value="110" class="slider" name="lens_factor" style="width:800px"><output name="lens_factor_output">1.1</output></td>
                </tr>
                <!--<tr>
                    <td>inner_radius</td><td><input type="range" min="0" max="2000" value="110" class="slider" name="inner_radius" style="width:800px"><output name="inner_radius_output">1.1</output></td>
                </tr>--!>
                <tr>
                    <td>distance</td><td><input type="range" min="0" max="1000" value="500" class="slider" name="front_clip" style="width:800px"><output name="front_clip_output">0.0</output></td>
                </tr>
                <tr>
                    <td>fov</td><td><input type="range" min="0" max="360" value="90" class="slider" name="fov" style="width:800px"><output name="fov_output">90</output></td>
                </tr>
                <tr>
                    <td>radius</td><td><input type="range" min="0" max="1200" value="500" class="slider" name="outer_radius" style="width:800px"><output name="outer_radius_output">0.5</output></td>
                </tr>
                <tr>
                    <td>lens aspect ratio</td><td><input type="range" min="500" max="2000" value="1000" class="slider" name="lens_aspect" style="width:800px"><output name="lens_aspect_output">1.0</output></td>
                </tr>
                <tr>
                    <td>distortion</td><td><input type="range" min="0" max="10000" value="0" class="slider" name="distortion" style="width:800px"><output name="distortion_output">1.0</output></td>
                </tr>
                <tr>
                    <td>scale Height</td><td><input type="range" min="0" max="1000" value="1000" class="slider" name="output_scale" style="width:800px"><output name="output_scale_output">1.0</output></td>
                </tr>
                <tr>
                    <td>scale Width</td><td><input type="range" min="0" max="1000" value="1000" class="slider" name="output_scale_x" style="width:800px"><output name="output_scale_output_x">1.0</output></td>
                </tr>
                <tr>
                    <td>offset Y</td><td><input type="range" min="0" max="1000" value="500" class="slider" name="offset_y" style="width:800px"><output name="offset_y_output">0.0</output></td>
                </tr>
                <tr>
                    <td>offset X</td><td><input type="range" min="0" max="1000" value="500" class="slider" name="offset_x" style="width:800px"><output name="offset_x_output">0.0</output></td>
                </tr>
            </table>
            <div style="width:50%; display:block">
            <video name="videoElement" class="centeredVideo" loop controls autoplay hidden style="height:500px; position:relative; top:0; left:0">
                Your browser is too old which doesn't support HTML5 video.
            </video>
            <canvas id="canvas1" width="500" height="500" style="position:relative; top:0, left:0"></canvas>
            </div>
        </div></div>
        <div class="video-container" style="width:100%;">
            <div>
                <p name="fps">60</p>
                <div style="width: 100%;">

                    <div id="canvas_container" style="width:100%">
                    </div>


                </div>

            </div>
        </div>
        <div class="controls" style="visibility: hidden">
            <button onclick="flv_load()">Load</button>
            <button onclick="flv_start()">Start</button>
            <button onclick="flv_pause()">Pause</button>
            <button onclick="flv_destroy()">Destroy</button>
            <input style="width:100px" type="text" name="seekpoint"/>
            <button onclick="flv_seekto()">SeekTo</button>
        </div>
        <textarea name="logcatbox" class="logcatBox" rows="10" readonly style="visibility: hidden"></textarea>
    </div>

    <script src="../dist/EEN.MediaPlayer.js"></script>
    <script src="gl-matrix.js"></script>
    
    <script>
        var checkBoxFields = ['isLive', 'withCredentials', 'hasAudio', 'hasVideo'];
        var streamURL, mediaSourceURL;

        function loadPane(pane, container, dropdown) {
            pane.show_debug = true;
            var canvas = $('<canvas width=' + pane.width + ' height=' + pane.height + ' name=canvas style="padding: 1px"/>').appendTo(container);
            var line = document.createElement("option");
            line.text = pane.name;
            line.value = pane.name;
            dropdown.add(line);
        }
        function paneChanged(pane) {
            pane.show_debug = document.getElementsByName('show_original')[0].checked;

            if (!this.azimuth_override)
                pane.azimuth = document.getElementsByName('azimuth')[0].value;

            var shader = document.getElementsByName('scene_type')[0].value;

            pane.shader = shader;
            pane.lens_factor = document.getElementsByName('lens_factor')[0].value / 1000.0;

            pane.lens_aspect = document.getElementsByName('lens_aspect')[0].value / 1000.0;

            pane.front_clip = document.getElementsByName('front_clip')[0].value / 1000.0 - 0.5;
            pane.distortion = document.getElementsByName('distortion')[0].value / 1000.0 * -1;
            pane.fov = document.getElementsByName('fov')[0].value;
            pane.outer_radius = document.getElementsByName('outer_radius')[0].value / 1000.0;
            pane.show_original = document.getElementsByName('show_original')[0].checked;
            pane.scale.y = document.getElementsByName('output_scale')[0].value / 1000.0;
            pane.scale.x = document.getElementsByName('output_scale_x')[0].value / 1000.0;
            pane.offset.x = document.getElementsByName('offset_x')[0].value / 1000.0 - 0.5;
            pane.offset.y = document.getElementsByName('offset_y')[0].value / 1000.0 - 0.5;
            //pane.lens_width = document.getElementsByName('inner_radius')[0].value/1000.0;

            recalculatePaneVariables(pane);

        }
        function recalculatePaneVariables(pane) {
            pane.offset_vector = new Vec2(pane.offset.x, pane.offset.y);
            var azimuth = pane.azimuth * 0.0174533;
            pane.inverse_lens_aspect = 1.0 / pane.lens_aspect;
            pane.dir = new Vec2(Math.sin(azimuth), Math.cos(azimuth)); // calculate a direction based on given azimuth
            pane.center_pos = new Vec2(0.5, 0.5); // calculate center of our frustum

            pane.inner_radius = (pane.lens_factor / 2.0) + ((pane.lens_factor * pane.lens_factor) / (4 * pane.lens_width * pane.lens_factor)); // calculate our inner circle radius based on lensing

            var fov = pane.fov * 0.0174533;
            var halfFOV = fov / 2.0;

            var leftDir = new Vec2(Math.sin(halfFOV), Math.cos(halfFOV));
            var rightDir = new Vec2(Math.sin(-halfFOV), Math.cos(-halfFOV));

            pane.lStart = new Vec2(pane.dir.x * leftDir.y - pane.dir.y * leftDir.x, pane.dir.x * leftDir.x + pane.dir.y * leftDir.y);
            pane.rStart = new Vec2(pane.dir.x * rightDir.y - pane.dir.y * rightDir.x, pane.dir.x * rightDir.x + pane.dir.y * rightDir.y);
            pane.lStart.normalize();
            pane.rStart.normalize();


            pane.lpos = pane.center_pos.add(pane.dir.multiply(pane.front_clip - pane.inner_radius));
        }
        var processor = {
            timerCallback: function() {
                if (this.video.paused || this.video.ended) {
                    return;
                }
                this.computeFrame();
                var self = this;
                setTimeout(function () {
                    self.timerCallback();
                }, 1); // roughly 60 frames per second
            },

            initShaderProgram: function(gl, name, vsSource, fsSource) {
                const vertexShader = this.loadShader(gl, gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

                // Create the shader program

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                // If creating the shader program failed, alert

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                this.programInfo[name] = {
                    program: shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                        textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
                    },
                    uniformLocations: {
                        projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                        modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                        normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                        uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
                        lens_factor: gl.getUniformLocation(shaderProgram, 'lens_factor'),
                        lens_aspect: gl.getUniformLocation(shaderProgram, 'lens_aspect_ratio'),
                        inverse_lens_aspect: gl.getUniformLocation(shaderProgram, 'inverse_lens_aspect_ratio'),
                        azimuth: gl.getUniformLocation(shaderProgram, 'azimuth'),
                        near_width: gl.getUniformLocation(shaderProgram, 'near_width'),
                        front_clip: gl.getUniformLocation(shaderProgram, 'front_clip'),
                        distortion: gl.getUniformLocation(shaderProgram, 'distortion'),
                        outer_radius: gl.getUniformLocation(shaderProgram, 'outer_radius'),
                        show_orig: gl.getUniformLocation(shaderProgram, 'show_original'),
                        draw_debug: gl.getUniformLocation(shaderProgram, 'draw_debug'),
                        fov: gl.getUniformLocation(shaderProgram, 'fov'),
                        inner_radius: gl.getUniformLocation(shaderProgram, 'inner_radius'),
                        lStart: gl.getUniformLocation(shaderProgram, 'lStart'),
                        rStart: gl.getUniformLocation(shaderProgram, 'rStart'),
                        lpos: gl.getUniformLocation(shaderProgram, 'lpos'),
                        offset: gl.getUniformLocation(shaderProgram, 'offset'),
                        output_color: gl.getUniformLocation(shaderProgram, 'output_color')
                    },
                };

                return shaderProgram;
            },

            initBuffers: function(gl) {
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);


                var width = 2.0;
                var height = 2.0;
                var halfw = width/2.0;
                var halfh = height/2.0;

                const positions = [ -halfw, -halfh, 1.0,
                0.0, -halfh, 1.0,
                0.0, halfh, 1.0,
                halfw, -halfh, 1.0,
                halfw, halfh, 1.0,
                -halfw, halfh, 1.0];

                const indices = [
                    0, 1, 2,
                    0, 2, 5,
                    2, 1, 3,
                    2, 4, 3

                ];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);


                const textureCoordinates = [0, 0,
                    0.5, 0,
                    0.5, 1,
                    1, 0,
                    1, 1,
                    0, 1];//[-0.5, -0.5, 0, -0.5, 0, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];

                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                    gl.STATIC_DRAW);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);


                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                    new Uint16Array(indices), gl.STATIC_DRAW);

                return {
                    position: positionBuffer,
                    textureCoord: textureCoordBuffer,
                    indices: indexBuffer,
                };
            },

            //
            // Initialize a texture.
            //
            initTexture: function(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                return texture;
            },

            initTransparentTexture: function(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                const pixel = new Uint8Array([255, 255, 255, 60]);  // opaque blue
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixel);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

                return texture;
            },


            updateTexture: function(gl, texture, video) {
                const level = 0;
                const internalFormat = gl.RGBA;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                    srcFormat, srcType, video);
            },

            isPowerOf2: function(value) {
                return (value & (value - 1)) == 0;
            },

            loadShader: function(gl, type, source) {
                const shader = gl.createShader(type);

                // Send the source to the shader object

                gl.shaderSource(shader, source);

                // Compile the shader program

                gl.compileShader(shader);

                // See if it compiled successfully

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            },

            refreshVariables: function(gl) {

                if (!this.panes)
                    return;

                var dropdown = document.getElementById('pane_dropdown');
                var pane = this.panes[dropdown.selectedIndex];
                paneChanged.call(this, pane);



//                var canvas = document.createElement('canvas');
//                canvas.width = this.video.videoWidth;
//                canvas.height = this.video.videoHeight;
//                var context = canvas.getContext('2d');
//
//                context.drawImage(this.video, 0, 0);
//                console.log(canvas.toDataURL("image/png"));
//                if (this.video.videoWidth > 0) {
//
//                    var theData = context.getImageData(0, 0, this.video.videoWidth, this.video.videoHeight);
//
//
//                    var x = 0;
//                    var y = this.video.videoHeight/2.0;
//
//                    var getLuminosity = function(data, video, x, y) {
//                        var idx = (i + y * video.videoWidth) * 4;
//                        var red = theData.data[idx + 0] / 255.0;
//                        var green = theData.data[idx + 1] / 255.0;
//                        var blue = theData.data[idx + 2] / 255.0;
//
//                        console.log("Color: X: " + i + " Y: " + y + "(" + red + ", " + green + ", " + blue + ")");
//                        return (0.2126*red + 0.7152*green + 0.0722*blue);
//                    }
//
//                    for (var i = 0; i < this.video.videoWidth; i++) {
//                        var lumin = getLuminosity(theData.data, this.video, i, y);
//                    }
//                }


                this.near_width = this.lens_factor;

                this.frustum = [0, 0,
                0.5, 0,
                0.5, 1,
                1, 0,
                1, 1,
                0, 1];

                //this.frustum = [-0.5, -0.5, 0, -0.5, 0, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5];

                this.extents = [this.nearw, this.start_dist, this.farw, this.end_dist]


                this.frustum_positions = [
                    (this.near_center_x + this.norm_x * this.near_hwidth + 0.5), (this.near_center_y + this.norm_y * this.near_hwidth + 0.5), 1,// bottom right
                    (this.near_center_x + 0.5), (this.near_center_y + 0.5), 1,// mid bottom
                    (this.far_center_x + 0.5), (this.far_center_y + 0.5), 1,// mid top
                    (this.near_center_x - this.norm_x * this.near_hwidth + 0.5), (this.near_center_y - this.norm_y * this.near_hwidth + 0.5), 1,// bottom left
                    (this.far_center_x - this.norm_x * this.far_hwidth + 0.5), (this.far_center_y - this.norm_y * this.far_hwidth + 0.5), 1,// top right
                    (this.far_center_x + this.norm_x * this.far_hwidth + 0.5), (this.far_center_y + this.norm_y * this.far_hwidth + 0.5), 1
                ];


                if (!this.frustum_verts)
                    this.frustum_verts = gl.createBuffer();

                gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_verts);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.frustum), gl.STATIC_DRAW);

                if (!this.frustum_vert_pos)
                    this.frustum_vert_pos = gl.createBuffer()

                gl.bindBuffer(gl.ARRAY_BUFFER, this.frustum_vert_pos);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.frustum_positions), gl.STATIC_DRAW);

                document.getElementById('pane_output').value = JSON.stringify(this.panes, null, 2);
                //console.log(this.frustum);
                //console.log(this.frustum_positions);
            },

            loadShaderNamed: function(name) {
                var self = this;
                $.ajax({url: name + '.frag', async:false, success: function(data) {
                    self.fs = data;
                    if (self.vs && self.fs) {
                        self.shaderPrograms[name] = self.initShaderProgram(self.gl, name, self.vs, self.fs);
                    }
                }});

                $.ajax({url: name+'.vert', async:false, success: function(data) {
                    self.vs = data;

                    if (self.vs && self.fs) {
                        self.shaderPrograms[name] = self.initShaderProgram(self.gl, name, self.vs, self.fs);
                    }
                }});
            },
            loadPanes: function() {
                var self = this;

                $.ajax({url: 'panes.json', dataType: "json", async:false, success: function(data) {
                    self.panes = data;
                    var container = document.getElementById('canvas_container');
                    var dropdown = document.getElementById('pane_dropdown');
                    dropdown.innerHTML = "";
                    self.panes.forEach(function(e) {
                        loadPane(e, container, dropdown);

                    });
                    self.load_pane(self.panes[0]);



                },
                error: function(e) {
                    console.log(e);
                }});
            },
            load_pane: function(pane) {

                this.panes.forEach(function (e) {
                    if (e === pane) {
                        e.output_color = [0.0, 1.0, 0.0, 1.0];
                    } else {
                        e.output_color = [1.0, 0.0, 0.0, 1.0];
                    }
                });

                self.ignore_changes = true;
                document.getElementsByName('azimuth')[0].value = pane.azimuth;
                document.getElementsByName('lens_factor')[0].value = pane.lens_factor * 1000.0;
                document.getElementsByName('lens_aspect')[0].value = pane.lens_aspect * 1000.0;
                //document.getElementsByName('inner_radius')[0].value = pane.inner_radius * 1000.0;
                document.getElementsByName('front_clip')[0].value = (pane.front_clip + 0.5) * 1000.0;
                document.getElementsByName('distortion')[0].value = (pane.distortion) * 1000.0 * -1;
                document.getElementsByName('fov')[0].value = pane.fov;
                document.getElementsByName('outer_radius')[0].value = pane.outer_radius * 1000.0;
                document.getElementsByName('output_scale')[0].value = pane.scale.y * 1000.0;
                document.getElementsByName('output_scale_x')[0].value = pane.scale.x * 1000.0;
                document.getElementsByName('offset_x')[0].value = pane.offset.x * 1000.0 + 500;
                document.getElementsByName('offset_y')[0].value = pane.offset.y * 1000.0 + 500;

                document.getElementsByName('azimuth_output')[0].value = pane.azimuth;
                document.getElementsByName('lens_factor_output')[0].value = pane.lens_factor;
                document.getElementsByName('lens_aspect_output')[0].value = pane.lens_aspect;
                //document.getElementsByName('inner_radius_output')[0].value = pane.inner_radius;
                document.getElementsByName('front_clip_output')[0].value = pane.front_clip;
                document.getElementsByName('distortion_output')[0].value = pane.distortion;
                document.getElementsByName('fov_output')[0].value = pane.fov;
                document.getElementsByName('outer_radius_output')[0].value = pane.outer_radius;
                document.getElementsByName('output_scale_output')[0].value = pane.scale.y;
                document.getElementsByName('output_scale_output_x')[0].value = pane.scale.x;
            document.getElementsByName('show_original')[0].value = pane.show_debug;
            self.ignore_changes = false;
        },
            doLoad: function() {

                this.ignore_changes = false;
                this.projectionMatrix = mat4.create();
                mat4.ortho(this.projectionMatrix, -1.0, 1.0, -1, 1, 0.1, 100);
                document.onkeydown = checkKey;
                var self = this;
                function checkKey(e) {

                    e = e || window.event;

                    if (e.keyCode == '38') {
                        // up arrow
                        document.getElementsByName('front_clip')[0].value = document.getElementsByName('front_clip')[0].value + 1;
                        self.refreshVariables(self.gl);
                    }
                    else if (e.keyCode == '40') {
                        // down arrow
                        document.getElementsByName('front_clip')[0].value = document.getElementsByName('front_clip')[0].value - 1;
                        self.refreshVariables(self.gl);
                    }
                    else if (e.keyCode == '37') {
                        document.getElementsByName('azimuth')[0].value = document.getElementsByName('azimuth')[0].value - 1;
                        self.refreshVariables(self.gl);
                        console.log("left");
                    }
                    else if (e.keyCode == '39') {
                        // right arrow
                        document.getElementsByName('azimuth')[0].value = document.getElementsByName('azimuth')[0].value + 1;
                        console.log("right " + document.getElementsByName('azimuth')[0].value);
                        self.refreshVariables(self.gl);
                    }

                }

                this.programInfo = new Object();
                this.shaderPrograms = new Object();
                this.video = document.getElementsByName("videoElement")[0];
                this.c1 = document.getElementById("canvas1");
                this.gl = this.c1.getContext('webgl');

                const gl = this.gl;
                // Initialize a shader program; this is where all the lighting
                // for the vertices and so forth is established.


                // Collect all the info needed to use the shader program.
                // Look up which attributes our shader program is using
                // for aVertexPosition, aVertexNormal, aTextureCoord,
                // and look up uniform locations.


                // Here's where we call the routine that builds all the
                // objects we'll be drawing.
                this.loadPanes();
                this.loadShaderNamed('ceiling');
                this.loadShaderNamed('debug');
                this.loadShaderNamed('extended_debug');
                this.loadShaderNamed('linear');
                this.loadShaderNamed('floor');

                this.buffers = this.initBuffers(gl);

                this.texture = this.initTexture(gl);
                this.transparent_texture = this.initTransparentTexture(gl);

                this.refreshVariables(this.gl);
                var self = this;

                document.getElementsByName('scene_type')[0].addEventListener('change', function(e) {
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('azimuth')[0].addEventListener('input', function(e) {
                    document.getElementsByName('azimuth_output')[0].value = e.target.value;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('lens_factor')[0].addEventListener('input', function(e) {
                    document.getElementsByName('lens_factor_output')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('lens_aspect')[0].addEventListener('input', function(e) {
                    document.getElementsByName('lens_aspect_output')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('distortion')[0].addEventListener('input', function(e) {
                    document.getElementsByName('distortion_output')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });
                // document.getElementsByName('inner_radius')[0].addEventListener('input', function(e) {
                //     document.getElementsByName('inner_radius_output')[0].value = e.target.value / 1000.0;
                //     if (self.ignore_changes)
                //         return;
                //
                //     self.refreshVariables(self.gl);
                // });
                document.getElementsByName('front_clip')[0].addEventListener('input', function(e) {
                    document.getElementsByName('front_clip_output')[0].value = e.target.value / 1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('fov')[0].addEventListener('input', function(e) {
                    document.getElementsByName('fov_output')[0].value = e.target.value;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });
                document.getElementsByName('outer_radius')[0].addEventListener('input', function(e) {
                    document.getElementsByName('outer_radius_output')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('output_scale')[0].addEventListener('input', function(e) {
                    document.getElementsByName('output_scale_output')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('output_scale_x')[0].addEventListener('input', function(e) {
                    document.getElementsByName('output_scale_output_x')[0].value = e.target.value/1000.0;
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('offset_x')[0].addEventListener('input', function(e) {
                    document.getElementsByName('offset_x_output')[0].value = (e.target.value/1000.0 - 0.5).toFixed(3);
                    if (self.ignore_changes)
                        return;
                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('offset_y')[0].addEventListener('input', function(e) {
                    document.getElementsByName('offset_y_output')[0].value = (e.target.value/1000.0 - 0.5).toFixed(3);
                    if (self.ignore_changes)
                        return;

                    self.refreshVariables(self.gl);
                });

                document.getElementsByName('show_original')[0].addEventListener('input', function() {
                    if (self.ignore_changes)
                        return;
                    self.refreshVariables(self.gl);
                });

                document.getElementById('pane_dropdown').addEventListener('change', function(e) {
                    var pane = self.panes[e.target.selectedIndex];
                    self.load_pane(pane);
                });

                self.mouse_down = false;

                this.c1.addEventListener("mousedown", function(e) {
                    self.mouse_down = true;
                }, false);

                this.c1.addEventListener("mouseup", function(e) {
                   self.mouse_down = false;
                });

                this.c1.addEventListener("mousemove", function(e)
                {
                    if (!self.mouse_down)
                        return;

                    var x = event.x;
                    var y = event.y;

                    var canvas = document.getElementById("canvas1");
                    var rect = canvas.getBoundingClientRect();
                    var midx = canvas.width;
                    var midy = canvas.height;

                    x -= rect.left;
                    y -= rect.top;

                    x = (x / canvas.width) - 0.5;
                    y = (1 - (y / canvas.height)) * 2.0 - 0.5;

                    self.azimuth_override = true;
                    self.azimuth = Math.atan2(x, y);

                    //console.log("x:" + x + " y:" + y);
                }, false);



                this.video.addEventListener("play", function() {
                    self.width = self.video.width;
                    self.height = self.video.height;
                    self.timerCallback();
                }, false);
            },

            setShader: function (gl, programInfo, pane) {
                gl.useProgram(programInfo.program);

                 if (typeof pane.lStart === 'undefined')
                     self.recalculatePaneVariables(pane);
                //     self.paneChanged(pane);

                gl.uniform1f(programInfo.uniformLocations.azimuth, pane.azimuth * 0.0174533);
                gl.uniform1f(programInfo.uniformLocations.lens_factor, pane.lens_factor);
                gl.uniform1f(programInfo.uniformLocations.lens_aspect, pane.lens_aspect);
                gl.uniform1f(programInfo.uniformLocations.inverse_lens_aspect, pane.inverse_lens_aspect);
                gl.uniform1f(programInfo.uniformLocations.front_clip, pane.front_clip);

                if (programInfo.uniformLocations.distortion)
                    gl.uniform1f(programInfo.uniformLocations.distortion, pane.distortion);

                gl.uniform1f(programInfo.uniformLocations.near_width, pane.lens_factor);
                gl.uniform1f(programInfo.uniformLocations.outer_radius, pane.outer_radius);
                gl.uniform1i(programInfo.uniformLocations.show_orig, 1);
                gl.uniform1i(programInfo.uniformLocations.draw_debug, 1);
                gl.uniform1f(programInfo.uniformLocations.fov, pane.fov * 0.0174533);

                gl.uniform1f(programInfo.uniformLocations.inner_radius, pane.inner_radius);

                gl.uniform2fv(programInfo.uniformLocations.lStart, pane.lStart.toArray());
                gl.uniform2fv(programInfo.uniformLocations.rStart, pane.rStart.toArray());
                gl.uniform2fv(programInfo.uniformLocations.lpos, pane.lpos.toArray());
                gl.uniform2fv(programInfo.uniformLocations.offset, pane.offset_vector.toArray());
            },
            drawPane: function (gl, pane, programInfo, offset, scale, projectionMatrix) {
///                console.log('drawing pane: ' + JSON.stringify(pane));
                const modelViewMatrix = mat4.create();
                mat4.translate(modelViewMatrix,     // destination matrix
                    modelViewMatrix,     // matrix to translate
                    offset);  // amount to translate
                const normalMatrix = mat4.create();

                mat4.scale(modelViewMatrix, modelViewMatrix, scale);

                mat4.invert(normalMatrix, modelViewMatrix);
                mat4.transpose(normalMatrix, normalMatrix);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);

                if (pane["animation"]) {
                    var animation = pane["animation"]
                    if (!animation["start_time"]) {
                        animation["start_time"] = Date.now();
                        pane.azimuth = pane.azimuth - parseFloat(animation["azimuth"]) * 0.5;
                        pane["original_azimuth"] = parseFloat(pane.azimuth);
                    }

                    var anim_azimuth = parseFloat(animation["azimuth"]);

                    var elapsed = (Date.now() - animation["start_time"]) / 1000.0;
                    var reversed = Math.floor(elapsed / animation["duration"]) % 2;
                    var progress = (elapsed % animation["duration"]) / animation["duration"] * anim_azimuth;
                    if (reversed) {
                        pane.azimuth = pane.original_azimuth + anim_azimuth - progress;
                    } else {
                        pane.azimuth = pane.original_azimuth + progress;
                    }
                    self.recalculatePaneVariables(pane);
                }

                this.setShader(gl, programInfo, pane);
                gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.textureCoord);
                gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.indices);


                gl.uniformMatrix4fv(programInfo.uniformLocations.projectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.modelViewMatrix, false, modelViewMatrix);
                gl.uniformMatrix4fv(programInfo.uniformLocations.normalMatrix, false, normalMatrix);


                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

                gl.drawElements(gl.TRIANGLES, 12, gl.UNSIGNED_SHORT, 0);
            }, computeFrame: function() {
                var self = this;

                if (!this.shaderPrograms['ceiling'] || !this.panes)
                    return;

                const gl = this.gl;
                gl.clearColor(0.0, 0.0, 0.0, 1.0);  // Clear to black, fully opaque
                gl.clearDepth(1.0);                 // Clear everything
                gl.enable(gl.DEPTH_TEST);           // Enable depth testing
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                // Clear the canvas before we start drawing on it.
                var elements = document.getElementsByName('canvas');
                this.updateTexture(this.gl, this.texture, this.video);
                if (elements.length > 0 ) {
                    for (var i = 0; i < this.panes.length && i < elements.length; i++) {
                        var pane = this.panes[i];
                        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                        this.drawPane(gl, this.panes[i], this.programInfo[this.panes[i].shader], [0, 0, -2.0], [1.0*pane.scale.x, 1.0*pane.scale.y, 1], this.projectionMatrix);
                        elements[i].getContext('2d').drawImage(self.c1, 0, 0, self.c1.width, self.c1.height, 0, 0, elements[i].width, elements[i].height);
                    }
                } else {
                    this.updateTexture(this.gl, this.texture, this.video);
                }
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.depthFunc(gl.ALWAYS);            // Near things obscure far things
                this.drawPane(gl, this.panes[0], this.programInfo['linear'], [0.0, 0.0, -2.0], [1.0, 1.0, 1.0], this.projectionMatrix);
                gl.useProgram(this.programInfo['debug'].program);
                for (var i=0; i<this.panes.length; i++) {
                    if (this.panes[i].show_debug) {
                        gl.uniform4fv(this.programInfo['debug'].uniformLocations.output_color, this.panes[i].output_color);
                        this.drawPane(gl, this.panes[i], this.programInfo['debug'], [0.0, 0.0, -2.0], [1.0, 1.0, 1.0], this.projectionMatrix);
                    }
                }
                gl.depthFunc(gl.LEQUAL);            // Near things obscure far things
//
//                var self = this;
//                elements.forEach(function(element) {
//                   element.getContext('2d').drawImage(self.c1, 0, 0);
//                });
                return;
            }
        };

        function flv_load() {
            console.log('isSupported: ' + EEN.MediaPlayer.flvjs.isSupported());
            if (mediaSourceURL.className === '') {
                var url = document.getElementById('msURL').value;
    
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.onload = function (e) {
                    var mediaDataSource = JSON.parse(xhr.response);
                    flv_load_mds(mediaDataSource);
                }
                xhr.send();
            } else {
                var i;
                var mediaDataSource = {
                    type: 'flv'
                };
                for (i = 0; i < checkBoxFields.length; i++) {
                    var field = checkBoxFields[i];
                    /** @type {HTMLInputElement} */
                    var checkbox = document.getElementById(field);
                    mediaDataSource[field] = checkbox.checked;
                }
                mediaDataSource['url'] = document.getElementById('sURL').value;
                console.log('MediaDataSource', mediaDataSource);
                flv_load_mds(mediaDataSource);
            }
        }

        function flv_load_mds(mediaDataSource) {
            var element = document.getElementsByName('videoElement')[0];
            if (typeof player !== "undefined") {
                if (player != null) {
                    player.unload();
                    player.detachMediaElement();
                    player.destroy();
                    player = null;
                }
            }
           player = EEN.MediaPlayer.flvjs.createPlayer(mediaDataSource, {
                   enableWorker: false,
                   lazyLoad: false,
                   lazyLoadRecoverDuration: 0,
                  cors: false,
                   seekType: 'param',
               });
           player.attachMediaElement(element);
           player.load();
           element.addEventListener('playing', function (e) {
              element.className = "";
           });

           element.addEventListener('ended', function(e) {
              element.className = "centered_video";
           });
            //player = EEN.MediaPlayer.startLive('100f9f23', 'c013~d3955ca427b0a55d7f7d019245853228', element);
            processor.doLoad();
        }

        function flv_start() {
            player.play();
        }

        function flv_pause() {
            player.pause();
        }

        function flv_destroy() {
            var audio = player._getAudio();
            audio.initPlayback(document.getElementsByName('videoElement')[0]);
        }

        function flv_seekto() {
            var input = document.getElementsByName('seekpoint')[0];
            player.currentTime = parseFloat(input.value);
        }

        function switch_url() {
            streamURL.className = '';
            mediaSourceURL.className = 'hidden';
            saveSettings();
        }

        function add_pane() {
            var pane = this.panes[this.panes.length-1];

        }

        function switch_mds() {
            streamURL.className = 'hidden';
            mediaSourceURL.className = '';
            saveSettings();
        }

        function ls_get(key, def) {
            try {
                var ret = localStorage.getItem('flvjs_demo.' + key);
                if (ret === null) {
                    ret = def;
                }
                return ret;
            } catch (e) {}
            return def;
        }

        function ls_set(key, value) {
            try {
                localStorage.setItem('flvjs_demo.' + key, value);
            } catch (e) {}
        }

        function saveSettings() {
            if (mediaSourceURL.className === '') {
                ls_set('inputMode', 'MediaDataSource');
            } else {
                ls_set('inputMode', 'StreamURL');
            }
            var i;
            for (i = 0; i < checkBoxFields.length; i++) {
                var field = checkBoxFields[i];
                /** @type {HTMLInputElement} */
                var checkbox = document.getElementById(field);
                ls_set(field, checkbox.checked ? '1' : '0');
            }
            var msURL = document.getElementById('msURL');
            var sURL = document.getElementById('sURL');
            ls_set('msURL', msURL.value);
            ls_set('sURL', sURL.value);
            console.log('save');
        }

        function loadSettings() {
            var i;
            for (i = 0; i < checkBoxFields.length; i++) {
                var field = checkBoxFields[i];
                /** @type {HTMLInputElement} */
                var checkbox = document.getElementById(field);
                var c = ls_get(field, checkbox.checked ? '1' : '0');
                checkbox.checked = c === '1' ? true : false;
            }

            var msURL = document.getElementById('msURL');
            var sURL = document.getElementById('sURL');
            msURL.value = ls_get('msURL', msURL.value);
            sURL.value = ls_get('sURL', sURL.value);
            if (ls_get('inputMode', 'StreamURL') === 'StreamURL') {
                switch_url();
            } else {
                switch_mds();
            }
        }

        function showVersion() {
            var version = EEN.MediaPlayer.flvjs.version;
            document.title = document.title + " (v" + version + ")";
        }

//        var logcatbox = document.getElementsByName('logcatbox')[0];
//        EEN.MediaPlayer.flvjs.LoggingControl.addLogListener(function(type, str) {
//            logcatbox.value = logcatbox.value + str + '\n';
//            logcatbox.scrollTop = logcatbox.scrollHeight;
//        });

        document.addEventListener('DOMContentLoaded', function () {
            streamURL = document.getElementById('streamURL');
            mediaSourceURL = document.getElementById('mediaSourceURL');
            loadSettings();
            showVersion();
            flv_load();
        });
    </script>
    
</body>

</html>
